一、乱序执行，消除假相关举例
假设有如下伪代码（假设只有一个逻辑寄存器R1）：

问题：

指令1和指令2都写R1，属于“写后写”假相关（WAW）。
指令2和指令3之间有“写后读”假相关（WAR）。
使用寄存器别名表（重命名）后的执行
假设CPU有多个物理寄存器（P1、P2、P3）：

指令1：R1 = 5
 分配物理寄存器P1，R1→P1

指令2：R1 = 8
 分配物理寄存器P2，R1→P2
 此时，P1和P2都保存了R1的不同历史值

指令3：R2 = R1 + 1
 此时R1映射到P2，所以实际执行的是：R2 = P2 + 1

效果
指令1和指令2虽然都写R1，但实际写的是不同的物理寄存器（P1、P2），消除了写后写假相关。
指令3读取的是最新的R1（即P2），不会被指令1的写入影响，消除了写后读假相关。
总结：
寄存器别名表通过为每次写操作分配新的物理寄存器，让逻辑寄存器的多次写入和读取互不干扰，从而消除假相关，提高乱序执行效率

Intel 架构过于具体
